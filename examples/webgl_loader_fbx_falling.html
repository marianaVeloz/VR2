<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Alienrinto VR</title>
    <link rel="icon" type="image" href="assets/icono.png">
    <style>
        /* Estilos generales del cuerpo: tipografía Arial, fondo negro, sin márgenes */
        body { margin:0; background:#000; color:#fff; font-family: Arial, sans-serif; overflow:hidden; }
        
        /* Contenedor de información simple (esquina superior izquierda) */
        #info { position:absolute; top:8px; left:8px; z-index:10; background:rgba(0,0,0,0.4); padding:8px; border-radius:6px; font-size: 14px; }
        
        /* HUD (Head-Up Display): Vida y Enemigos - POSICIÓN VISIBLE EN VR */
        #hud { 
            position: absolute; 
            left: 20px; 
            bottom: 100px; /* Sobre el footer */
            z-index: 100; 
            background: rgba(0, 0, 0, 0.75); 
            padding: 15px; 
            border-radius: 10px; 
            text-align: left; 
            min-width: 180px; 
            display: none;
            border: 2px solid #22ff88;
            backdrop-filter: blur(5px);
            font-size: 18px;
        }

        #hud div {
            margin: 8px 0;
        }

        #hud strong {
            color: #22ff88;
            margin-right: 10px;
        }

        #hud span {
            color: #fff;
            font-weight: bold;
        }
        
        /* Mensajes centrales (¡GANASTE! / GAME OVER) */
        #message { 
            position: absolute; 
            left:50%; 
            top:45%; 
            transform:translateX(-50%); 
            z-index:12; 
            pointer-events:none; 
            font-size:28px; 
            background:rgba(0,0,0,0.6); 
            padding:12px 20px; 
            border-radius:8px; 
            display:none; 
            white-space: pre-wrap; /* <-- ¡IMPORTANTE! Permite saltos de línea con \n */
            text-align: center;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            padding: 20px 40px;
            border: 3px solid;
            border-radius: 15px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
            100% { transform: translateX(-50%) scale(1); }
        }

        /* -------- PORTADA INICIAL -------- */
        #portada {
            position: fixed;
            inset: 0;
            background: rgb(0, 0, 0);
            background-size: cover;
            background-blend-mode: overlay;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            text-align: center;
            padding: 20px;
        }
        
        #portada-content {
            max-width: 700px;
            background: rgba(0,0,0,0.6);
            padding: 40px;
            border-radius: 14px;
            box-shadow: 0 0 20px rgba(0,255,150,0.4);
            border: 1px solid #22ff88;
        }

        #portada h1 {
            font-size: 48px;
            color: #22ff88;
            margin-bottom: 10px;
        }

        #portada .sub {
            font-size: 18px;
            margin-bottom: 18px;
            color: #ccc;
        }

        #portada h2 {
            margin-top: 20px;
            color: #22ff88;
        }

        #portada ul {
            list-style: none;
            padding: 0;
        }

        #portada ul li {
            margin: 6px 0;
        }

        #portada .equipo {
            color: #ddd;
            line-height: 1.6;
        }

        #startBtn {
            margin-top: 28px;
            padding: 12px 32px;
            font-size: 18px;
            border: none;
            background: #22ff88;
            color: #000;
            border-radius: 8px;
            cursor: pointer;
            transition: 0.2s ease;
            font-weight: bold;
        }

        #startBtn:hover {
            background: #44ffaa;
        }

        .vr-button {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            background: linear-gradient(45deg, #2196F3, #21CBF3);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
            transition: all 0.3s ease;
            display: none;
        }

        .vr-button:hover {
            background: linear-gradient(45deg, #1976D2, #1E88E5);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(33, 150, 243, 0.6);
        }

        .vr-button:active {
            transform: translateY(0);
        }
        
        /* Mira del jugador (cruz en el centro) */
        .crosshair { 
            position: absolute; 
            left:50%; 
            top:50%; 
            transform:translate(-50%,-50%); 
            width:12px; 
            height:12px; 
            z-index:9; 
            pointer-events:none; 
            opacity:0.85; 
            display: none;
        }
        .crosshair:before, .crosshair:after { content:""; position:absolute; background:#fff; }
        .crosshair:before { left:50%; top:0; width:2px; height:100%; transform:translateX(-50%); }
        .crosshair:after  { top:50%; left:0; height:2px; width:100%; transform:translateY(-50%); }
        
        /* Pie de página (Footer) para créditos y controles */
        footer { 
            position:fixed; 
            left:0; 
            right:0; 
            bottom:0; 
            background:rgba(0,0,0,0.6); 
            color:#fff; 
            padding:10px 16px; 
            display:flex; 
            justify-content:space-between; 
            align-items:center; 
            z-index:5; 
            font-family: Arial, sans-serif; /* Requisito: Arial */
            display: none;
        }
        
        /* Estilo para el <h1> del Título */
        footer h1 {
            margin: 0 0 5px 0;
            font-size: 20px;
            font-weight: bold;      /* Requisito: Negrita */
            color: #22ff88;         /* Requisito: Color acorde (verde del portal) */
        }

        /* Estilo para el "Tablero de Teclas" */
        #key-board {
            font-size: 12px;
            line-height: 1.5;
        }
        #key-board strong {
            color: #22ff88;
            min-width: 60px;
            display: inline-block;
        }

        /* Estilo para la info del Equipo */
        #team-info {
            text-align: right;
            font-size: 13px;
            line-height: 1.5;
        }
        
        canvas { 
            display:none; 
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Botón de reinicio */
        #restartBtn {
            position: absolute;
            left: 50%;
            top: 60%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background: #22ff88;
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            display: none;
            z-index: 13;
        }

        #restartBtn:hover {
            background: #44ffaa;
        }

        /* Información VR */
        #vr-info { 
            position: absolute; 
            top: 80px; 
            right: 20px; 
            background: rgba(0,0,0,0.7); 
            padding: 15px; 
            border-radius: 8px; 
            z-index: 11; 
            display: none; 
        }

        /* LETRERO AL ENTRAR A VR - TEMPORAL */
        #vr-enter-sign {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 25px 40px;
            border-radius: 12px;
            border: 3px solid #22ff88;
            z-index: 9999;
            text-align: center;
            font-family: Arial, sans-serif;
            box-shadow: 0 0 30px rgba(34, 255, 136, 0.7);
            display: none;
            width: 320px;
        }
        
        #vr-enter-sign h2 {
            color: #22ff88;
            margin: 0 0 15px 0;
            font-size: 24px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #vr-enter-sign .stats {
            font-size: 20px;
            margin: 15px 0;
            line-height: 1.6;
        }
        
        #vr-enter-sign .stats span {
            color: #22ff88;
            font-weight: bold;
        }
        
        #vr-enter-sign .tip {
            font-size: 14px;
            color: #aaa;
            margin-top: 20px;
            font-style: italic;
        }
        
    </style>

    <!-- Importar Three.js desde CDN -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/"
        }
    }
    </script>

</head>
<body>
    <!-- Audio -->
    <audio id="shootSound" src="assets/Disparo.mp3"></audio>
    <audio id="explosionSound" src="assets/Explosion.mp3"></audio>
    <audio id="enemyDeathSound" src="assets/Muerte_enemigos.mp3"></audio>
    <audio id="backgroundMusic" loop>
        <source src="assets/musica.mp3" type="audio/mpeg">
    </audio>

    <!-- PORTADA INICIAL -->
    <div id="portada">
        <div id="portada-content">
            <h1>Alienrinto VR</h1>
            <p class="sub"> >>>>>> Experiencia VR para Meta Quest 3 <<<<<< </p>

            <h2>Instrucciones VR</h2>
            <ul>
                <li><strong>Joystick izquierdo</strong> - Movimiento</li>
                <li><strong>Gatillo derecho</strong> - Disparar</li>
                <li><strong>Botón A/X</strong> - Saltar</li>
                <li><strong>Botón de menú</strong> - Pausa/Salir VR</li>
            </ul>
            <h2>Objetivo:</h2>
            <p>Llega al portal sin que los aliens te maten</p>

            <h2>Integrantes del Equipo</h2>
            <p class="equipo">
                23200860 – Marquez Zempoalteca Judith<br>
                23200823 – Cruz Monter Sergio Eloy<br>
                23200904 – Veloz Pérez Mariana
            </p>

            <button id="startBtn">Iniciar Experiencia VR</button>
        </div>
    </div>

    <!-- HUD -->
    <div id="hud">
        <div><strong>Vida:</strong> <span id="life">100</span></div>
        <div><strong>Enemigos:</strong> <span id="enemiesCount">0</span></div>
        <div style="font-size:12px; margin-top:6px;">Objetivo: llegar al portal verde</div>
    </div>

    <!-- Mensajes -->
    <div id="message"></div>
    <button id="restartBtn">Jugar Otra Vez</button>

    <!-- Información VR -->
    <div id="vr-info">
        <h3>Controles Quest 3</h3>
        <ul>
            <li><strong>Joystick:</strong> Moverse</li>
            <li><strong>Gatillo derecho:</strong> Disparar</li>
            <li><strong>Botón A/X:</strong> Saltar</li>
        </ul>
    </div>

    <!-- Mira -->
    <div class="crosshair"></div>

    <!-- Letrero VR temporal -->
    <div id="vr-enter-sign">
        <h2>MODO VR ACTIVADO</h2>
        <div class="stats">
            Vida: <span id="vr-life">100</span>
        </div>
        <div class="stats">
            Enemigos restantes: <span id="vr-enemies">0</span>
        </div>
        <div class="tip">
            Este mensaje desaparecerá en unos segundos
        </div>
    </div>

    <!-- Canvas para Three.js -->
    <canvas id="scene"></canvas>

    <script type="module">
// -------------------------------------------------------------------
// ---------- CONFIGURACIÓN ----------
// -------------------------------------------------------------------
const CONFIG = {
    // Laberinto
    MAZE_COLS: 11,
    MAZE_ROWS: 11,
    CELL_SIZE: 80,
    WALL_HEIGHT: 20,
    WALL_THICKNESS: 8,
    
    // Enemigos
    ENEMY_COUNT: 8,
    ENEMY_HEALTH: 50,
    ENEMY_SPEED_MIN: 0.8,
    ENEMY_SPEED_MAX: 1.6,
    ENEMY_SIGHT_RANGE: 400,
    ENEMY_ATTACK_RANGE: 15,
    ENEMY_ATTACK_DAMAGE: 8,
    
    // Texturas
    FLOOR_TEX: 'models/rgbe/piso.jpg',
    WALL_TEX: 'models/rgbe/paredes.jpg',
    BACKGROUND_TEX: 'models/rgbe/fondo.hdr',
    
    // VR
    PLAYER_RADIUS: 0.35,
    VR_WALK_SPEED: 5.5,
    VR_STRAFE_SPEED: 4.8,
    
    // Otros
    FOG_DENSITY: 0.028,
    ARC_STEPS: 40,
    ARC_SPEED: 7.5,
    ARC_GRAVITY: 9.8,
    MAX_SLOPE_DEG: 45
};

// Importar módulos necesarios
import * as THREE from 'three';
import { VRButton } from 'three/addons/webxr/VRButton.js';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

// Variables globales
let scene, camera, player, renderer;
let physicsObjects = [];
let enemies = [];
let gameInitialized = false;
let clock = new THREE.Clock();
let bgScene, bgCam, skyMesh, starField;
let mainLight, hemiLight;
let listener;
let controllerLeft, controllerRight, grip0, grip1;
let arcLine, marker, teleportPoint;
let teleportValid = false;
let arcPointsBuf;
let arcMatOK, arcMatBAD, arcGeo;
let vrButton;

/** ========= INICIALIZAR RENDERER ========= */
function initRenderer() {
    const canvas = document.getElementById('scene');
    
    try {
        renderer = new THREE.WebGLRenderer({ 
            canvas, 
            antialias: true,
            alpha: true
        });
        
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.xr.enabled = true;
        renderer.autoClear = false;
        
        console.log("Renderer inicializado correctamente");
        return renderer;
    } catch (error) {
        console.error("Error al inicializar renderer:", error);
        alert("Error al inicializar WebGL. Verifica que tu navegador soporte WebGL y prueba en Chrome o Firefox.");
        throw error;
    }
}

/** ========= INICIALIZAR ESCENAS ========= */
function initScenes() {
    // Escena principal
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x06101a);
    scene.fog = new THREE.FogExp2(0x06101a, CONFIG.FOG_DENSITY);
    
    // Escena de fondo
    bgScene = new THREE.Scene();
    bgCam = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
    
    // Cámara del jugador
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
    player = new THREE.Group();
    player.add(camera);
    scene.add(player);
    
    console.log("Escenas inicializadas");
}

/** ========= INICIALIZAR LUCES - TEMÁTICA ALIENÍGENA ========= */
function initLights() {
    // Luz ambiental alienígena (verde/azul)
    const ambientLight = new THREE.AmbientLight(0x223344, 0.3);
    scene.add(ambientLight);
    
    // Luz hemisférica con tonos alienígenas
    hemiLight = new THREE.HemisphereLight(0x4477aa, 0x112233, 0.4);
    scene.add(hemiLight);
    
    // Luz direccional principal (como luz de luna alienígena)
    mainLight = new THREE.DirectionalLight(0xaaccff, 0.8);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.set(1024, 1024);
    mainLight.shadow.camera.near = 0.5;
    mainLight.shadow.camera.far = 500;
    mainLight.position.set(30, 50, 30);
    
    // Configurar sombras
    mainLight.shadow.camera.left = -100;
    mainLight.shadow.camera.right = 100;
    mainLight.shadow.camera.top = 100;
    mainLight.shadow.camera.bottom = -100;
    mainLight.shadow.bias = -0.001;
    
    scene.add(mainLight);
    
    // Luz de neón/portal (efecto especial)
    const portalLight = new THREE.PointLight(0x22ff88, 1.5, 200);
    portalLight.position.set(0, 20, 0);
    scene.add(portalLight);
    
    // Luces puntuales para ambiente (efecto de laboratorio alienígena)
    for (let i = 0; i < 4; i++) {
        const pointLight = new THREE.PointLight(0x4477ff, 0.5, 150);
        const angle = (i / 4) * Math.PI * 2;
        pointLight.position.set(
            Math.cos(angle) * 200,
            30,
            Math.sin(angle) * 200
        );
        scene.add(pointLight);
    }
    
    console.log("Iluminación de temática alienígena inicializada");
}

/** ========= INICIALIZAR CIELO ========= */
function initSky() {
    try {
        // Cargar HDR como fondo
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load(CONFIG.BACKGROUND_TEX, (texture) => {
            // Configurar la textura HDR
            texture.mapping = THREE.EquirectangularReflectionMapping;
            texture.encoding = THREE.sRGBEncoding;
            
            // Usar como fondo de la escena principal
            scene.background = texture;
            scene.environment = texture; // Para reflexiones
            
            // Crear skybox más simple
            const skyGeo = new THREE.SphereGeometry(1000, 60, 40);
            const skyMat = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.BackSide
            });
            
            skyMesh = new THREE.Mesh(skyGeo, skyMat);
            skyMesh.renderOrder = -2;
            bgScene.add(skyMesh);
            
            console.log("Fondo HDR cargado correctamente");
        }, undefined, (error) => {
            console.error("Error al cargar HDR:", error);
            // Fallback a color sólido
            scene.background = new THREE.Color(0x87CEEB);
        });
        
        // Estrellas simplificadas (mantener como complemento)
        const starCount = 1000;
        const starPositions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
            const r = 900 + Math.random() * 200;
            const a = Math.random() * Math.PI * 2;
            const b = Math.acos(2 * Math.random() - 1);
            starPositions[i * 3] = r * Math.sin(b) * Math.cos(a);
            starPositions[i * 3 + 1] = r * Math.cos(b);
            starPositions[i * 3 + 2] = r * Math.sin(b) * Math.sin(a);
        }
        
        const starGeo = new THREE.BufferGeometry();
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMat = new THREE.PointsMaterial({
            size: 1.5,
            sizeAttenuation: false,
            color: 0xffffff,
            fog: false,
            transparent: true,
            opacity: 0.8
        });
        
        starField = new THREE.Points(starGeo, starMat);
        starField.renderOrder = -1;
        bgScene.add(starField);
        
    } catch (error) {
        console.error("Error al inicializar cielo:", error);
        scene.background = new THREE.Color(0x06101a);
    }
}

/** ========= INICIALIZAR AUDIO ========= */
function initAudio() {
    try {
        listener = new THREE.AudioListener();
        camera.add(listener);
        
        // Iniciar música de fondo
        const backgroundMusic = document.getElementById('backgroundMusic');
        if (backgroundMusic) {
            backgroundMusic.volume = 0.3;
            backgroundMusic.play().catch(e => console.log('Audio bloqueado, requiere interacción del usuario:', e));
        }
        
        console.log("Audio inicializado");
    } catch (error) {
        console.error("Error al inicializar audio:", error);
    }
}

/** ========= DISPARAR - CON SONIDOS ========= */
function shoot() {
    // Reproducir sonido de disparo
    const shootSound = document.getElementById('shootSound');
    if (shootSound) {
        shootSound.currentTime = 0;
        shootSound.play().catch(e => console.log('Error al reproducir sonido de disparo:', e));
    }
    
    // Lógica de disparo
    if (camera && enemies.length > 0) {
        const raycaster = new THREE.Raycaster();
        const direction = new THREE.Vector3(0, 0, -1);
        direction.applyQuaternion(camera.quaternion);
        raycaster.set(camera.position, direction);
        
        const intersects = raycaster.intersectObjects(enemies);
        
        if (intersects.length > 0) {
            const enemy = intersects[0].object;
            
            if (enemy.userData.alive) {
                // Aplicar daño
                enemy.userData.health -= 25;
                
                // Reproducir sonido de explosión
                const explosionSound = document.getElementById('explosionSound');
                if (explosionSound) {
                    explosionSound.currentTime = 0;
                    explosionSound.play().catch(e => console.log('Error al reproducir explosión:', e));
                }
                
                // Efecto visual de daño
                enemy.material.emissive.setHex(0xff0000);
                setTimeout(() => {
                    if (enemy.material) {
                        enemy.material.emissive.setHex(0x220000);
                    }
                }, 100);
                
                // Verificar si el enemigo murió
                if (enemy.userData.health <= 0) {
                    enemy.userData.alive = false;
                    enemy.visible = false;
                    
                    // Reproducir sonido de muerte
                    const deathSound = document.getElementById('enemyDeathSound');
                    if (deathSound) {
                        deathSound.currentTime = 0;
                        deathSound.play().catch(e => console.log('Error al reproducir muerte:', e));
                    }
                }
                
                // Actualizar HUD
                updateHUD();
            }
        }
    }
}

/** ========= CONTROL DE DISPARO EN VR ========= */
function initVRShooting() {
    if (controllerRight) {
        controllerRight.addEventListener('selectstart', () => {
            shoot();
            
            // Disparo continuo mientras se mantiene presionado
            controllerRight.userData.shootingInterval = setInterval(shoot, 200);
        });
        
        controllerRight.addEventListener('selectend', () => {
            // Detener disparo continuo
            if (controllerRight.userData.shootingInterval) {
                clearInterval(controllerRight.userData.shootingInterval);
                controllerRight.userData.shootingInterval = null;
            }
        });
    }
    
    // También disparar con clic del mouse (para pruebas en desktop)
    document.addEventListener('click', (e) => {
        if (!renderer.xr.isPresenting && gameInitialized) {
            shoot();
        }
    });
    
    // Disparar con barra espaciadora (para pruebas en desktop)
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !renderer.xr.isPresenting && gameInitialized) {
            shoot();
            e.preventDefault();
        }
    });
}

/** ========= INICIALIZAR VR ========= */
function initVR() {
    try {
        // Botón VR
        vrButton = VRButton.createButton(renderer);
        vrButton.classList.add('vr-button');
        vrButton.style.display = 'block';
        document.body.appendChild(vrButton);
        
        console.log("Botón VR creado");
        
        // Evento cuando se entra en VR
        vrButton.addEventListener('click', () => {
            setTimeout(() => {
                if (renderer.xr.isPresenting) {
                    showVREnterSign();
                }
            }, 500);
        });
        
        // Esperar a que el renderer esté listo
        setTimeout(() => {
            // Controladores
            controllerLeft = renderer.xr.getController(0);
            controllerRight = renderer.xr.getController(1);
            
            if (controllerLeft && controllerRight) {
                scene.add(controllerLeft);
                scene.add(controllerRight);
                
                const controllerModelFactory = new XRControllerModelFactory();
                
                grip0 = renderer.xr.getControllerGrip(0);
                grip0.add(controllerModelFactory.createControllerModel(grip0));
                scene.add(grip0);
                
                grip1 = renderer.xr.getControllerGrip(1);
                grip1.add(controllerModelFactory.createControllerModel(grip1));
                scene.add(grip1);
                
                console.log("Controladores VR inicializados");
                
                // Arco de teleport
                arcMatOK = new THREE.LineBasicMaterial({ 
                    color: 0x7ad1ff, 
                    transparent: true, 
                    opacity: 0.95 
                });
                arcMatBAD = new THREE.LineBasicMaterial({ 
                    color: 0xff5a5a, 
                    transparent: true, 
                    opacity: 0.95 
                });
                
                arcGeo = new THREE.BufferGeometry().setFromPoints(
                    new Array(CONFIG.ARC_STEPS).fill(0).map(() => new THREE.Vector3())
                );
                arcLine = new THREE.Line(arcGeo, arcMatOK);
                arcLine.visible = false;
                scene.add(arcLine);
                
                marker = new THREE.Mesh(
                    new THREE.RingGeometry(0.25, 0.30, 32),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x7ad1ff, 
                        transparent: true, 
                        opacity: 0.9, 
                        side: THREE.DoubleSide 
                    })
                );
                marker.rotation.x = -Math.PI / 2;
                marker.visible = false;
                scene.add(marker);
                
                teleportPoint = new THREE.Vector3();
                arcPointsBuf = new Float32Array(CONFIG.ARC_STEPS * 3);
                
                // Eventos de teleport
                controllerRight.addEventListener('selectstart', () => { 
                    arcLine.visible = true; 
                    marker.visible = true; 
                });
                
                controllerRight.addEventListener('selectend', () => {
                    arcLine.visible = false;
                    marker.visible = false;
                    if (teleportValid) {
                        const floorY = -0.1 + 1.6;
                        player.position.set(teleportPoint.x, floorY, teleportPoint.z);
                        player.position.copy(resolveCollisions(player.position, player.position));
                    }
                });
                
                // Inicializar sistema de disparo
                initVRShooting();
                
                console.log("Sistema de teleport y disparo inicializado");
            } else {
                console.warn("Controladores VR no disponibles");
            }
        }, 100);
        
    } catch (error) {
        console.error("Error al inicializar VR:", error);
        // Crear botón VR simple como fallback
        const fallbackVRButton = document.createElement('button');
        fallbackVRButton.textContent = 'VR NO DISPONIBLE';
        fallbackVRButton.classList.add('vr-button');
        fallbackVRButton.style.background = '#ff4444';
        fallbackVRButton.style.cursor = 'not-allowed';
        document.body.appendChild(fallbackVRButton);
    }
}

/** ========= FUNCIÓN PARA MOSTRAR LETRERO VR - TEMPORAL ========= */
function showVREnterSign() {
    const vrSign = document.getElementById('vr-enter-sign');
    const vrLife = document.getElementById('vr-life');
    const vrEnemies = document.getElementById('vr-enemies');
    const lifeElement = document.getElementById('life');
    
    if (vrSign && vrLife && vrEnemies && lifeElement) {
        // Actualizar valores
        vrLife.textContent = lifeElement.textContent;
        vrEnemies.textContent = enemies.filter(e => e.userData.alive).length;
        
        // Mostrar letrero temporalmente
        vrSign.style.display = 'block';
        
        console.log("Letrero VR mostrado temporalmente");
        
        // Ocultar automáticamente después de 5 segundos
        setTimeout(() => {
            vrSign.style.display = 'none';
            console.log("Letrero VR ocultado");
        }, 5000);
    }
}

// -------------------------------------------------------------------
// ---------- GENERACIÓN DEL LABERINTO ----------
// -------------------------------------------------------------------
/** ========= GENERACIÓN DEL LABERINTO (altura reducida) ========= */
function generateMaze(rows, cols, cellSize) {
    console.log(`Generando laberinto ${rows}x${cols} (altura: ${CONFIG.WALL_HEIGHT})...`);
    
    const grid = [];
    for (let r = 0; r < rows; r++) {
        grid[r] = [];
        for (let c = 0; c < cols; c++) {
            grid[r][c] = { 
                r, c, 
                visited: false, 
                walls: [true, true, true, true]
            };
        }
    }
    
    const stack = [];
    let current = grid[0][0];
    current.visited = true;
    
    function getNeighbors(cell) {
        const n = [];
        const { r, c } = cell;
        
        if (r > 0 && !grid[r - 1][c].visited) n.push(grid[r - 1][c]);
        if (c < cols - 1 && !grid[r][c + 1].visited) n.push(grid[r][c + 1]);
        if (r < rows - 1 && !grid[r + 1][c].visited) n.push(grid[r + 1][c]);
        if (c > 0 && !grid[r][c - 1].visited) n.push(grid[r][c - 1]);
        
        return n;
    }
    
    while (true) {
        const neighbors = getNeighbors(current);
        
        if (neighbors.length > 0) {
            const next = neighbors[Math.floor(Math.random() * neighbors.length)];
            stack.push(current);
            
            const dr = next.r - current.r;
            const dc = next.c - current.c;
            
            if (dr === -1) {
                current.walls[0] = false;
                next.walls[2] = false;
            } else if (dc === 1) {
                current.walls[1] = false;
                next.walls[3] = false;
            } else if (dr === 1) {
                current.walls[2] = false;
                next.walls[0] = false;
            } else if (dc === -1) {
                current.walls[3] = false;
                next.walls[1] = false;
            }
            
            current = next;
            current.visited = true;
        } else if (stack.length > 0) {
            current = stack.pop();
        } else {
            break;
        }
    }
    
    const startX = -(cols * cellSize) / 2;
    const startZ = -(rows * cellSize) / 2;
    const wallHeightHalf = CONFIG.WALL_HEIGHT / 2; // Usar la nueva altura
    
    const wallGeo = new THREE.BoxGeometry(
        cellSize + CONFIG.WALL_THICKNESS, 
        CONFIG.WALL_HEIGHT, // Altura reducida
        CONFIG.WALL_THICKNESS
    );
    
    // Cargar textura de paredes
    const textureLoader = new THREE.TextureLoader();
    let wallMaterial;
    
    try {
        const wallTexture = textureLoader.load(CONFIG.WALL_TEX, 
            (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                const repeatX = (cellSize + CONFIG.WALL_THICKNESS) / 50;
                const repeatY = CONFIG.WALL_HEIGHT / 50;
                texture.repeat.set(repeatX, repeatY);
                console.log("Textura de paredes cargada correctamente");
            },
            undefined,
            (error) => {
                console.warn("Error al cargar textura de paredes:", error);
                wallMaterial = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    roughness: 0.8,
                    metalness: 0.2
                });
            }
        );
        
        wallMaterial = new THREE.MeshStandardMaterial({
            map: wallTexture,
            roughness: 0.8,
            metalness: 0.2
        });
    } catch (error) {
        console.warn("Error al crear material:", error);
        wallMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666,
            roughness: 0.8,
            metalness: 0.2
        });
    }
    
    function createWall(posX, posZ, rotY) {
        const wall = new THREE.Mesh(wallGeo, wallMaterial);
        wall.position.set(posX, wallHeightHalf, posZ);
        wall.rotation.y = rotY;
        wall.receiveShadow = true;
        wall.castShadow = true;
        scene.add(wall);
        
        wall.updateMatrixWorld();
        const wallBox = new THREE.Box3().setFromObject(wall);
        physicsObjects.push({ 
            mesh: wall, 
            boundingBox: wallBox, 
            static: true 
        });
        
        return wall;
    }
    
    // Crear todas las paredes internas
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            const cell = grid[r][c];
            const cx = startX + c * cellSize + cellSize / 2;
            const cz = startZ + r * cellSize + cellSize / 2;
            
            if (cell.walls[0]) createWall(cx, cz - cellSize / 2, 0);
            if (cell.walls[1]) createWall(cx + cellSize / 2, cz, Math.PI / 2);
            if (cell.walls[2]) createWall(cx, cz + cellSize / 2, 0);
            if (cell.walls[3]) createWall(cx - cellSize / 2, cz, Math.PI / 2);
        }
    }
    
    // Calcular y marcar el camino hacia el portal
    const path = findPathToGoal(grid, rows, cols);
    createPathMarkers(path, startX, startZ, cellSize);
    
    scene.userData.maze = { 
        grid, 
        startX, 
        startZ, 
        rows, 
        cols, 
        cellSize,
        path: path
    };
    
    console.log(`Laberinto generado: ${rows}x${cols} (altura: ${CONFIG.WALL_HEIGHT}) con marcadores de ruta`);
    return grid;
}

/** ========= ENCONTRAR CAMINO AL PORTAL ========= */
function findPathToGoal(grid, rows, cols) {
    console.log("Calculando camino hacia el portal...");
    
    // El portal está en la esquina inferior derecha (última celda)
    const startCell = grid[0][0]; // Celda inicial
    const goalCell = grid[rows-1][cols-1]; // Celda del portal
    
    // Usar BFS para encontrar el camino
    const queue = [{ cell: startCell, path: [startCell] }];
    const visited = new Set();
    visited.add(startCell);
    
    while (queue.length > 0) {
        const { cell, path } = queue.shift();
        
        // Si llegamos al portal
        if (cell === goalCell) {
            console.log("Camino encontrado con", path.length, "celdas");
            return path;
        }
        
        // Obtener vecinos accesibles
        const neighbors = [];
        const { r, c, walls } = cell;
        
        // Norte (pared 0)
        if (!walls[0] && r > 0) neighbors.push(grid[r-1][c]);
        // Este (pared 1)
        if (!walls[1] && c < cols-1) neighbors.push(grid[r][c+1]);
        // Sur (pared 2)
        if (!walls[2] && r < rows-1) neighbors.push(grid[r+1][c]);
        // Oeste (pared 3)
        if (!walls[3] && c > 0) neighbors.push(grid[r][c-1]);
        
        for (const neighbor of neighbors) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push({ 
                    cell: neighbor, 
                    path: [...path, neighbor] 
                });
            }
        }
    }
    
    console.log("No se encontró camino al portal");
    return [];
}

/** ========= CREAR MARCADORES DE RUTA ========= */
function createPathMarkers(path, startX, startZ, cellSize) {
    if (path.length === 0) return;
    
    console.log("Creando marcadores de ruta...");
    
    const markerGeo = new THREE.CylinderGeometry(8, 8, 2, 16);
    const markerMat = new THREE.MeshStandardMaterial({ 
        color: 0x22ff88,
        emissive: 0x22ff88,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.8
    });
    
    const arrowGeo = new THREE.ConeGeometry(6, 15, 8);
    const arrowMat = new THREE.MeshStandardMaterial({ 
        color: 0x22ff88,
        emissive: 0x22ff88,
        emissiveIntensity: 0.7
    });
    
    // Crear marcadores en cada celda del camino
    for (let i = 0; i < path.length; i++) {
        const cell = path[i];
        const cx = startX + cell.c * cellSize + cellSize / 2;
        const cz = startZ + cell.r * cellSize + cellSize / 2;
        
        // Marcador de piso (solo cada 3 celdas para no saturar)
        if (i % 3 === 0 || i === path.length - 1) {
            const marker = new THREE.Mesh(markerGeo, markerMat);
            marker.position.set(cx, 0.5, cz);
            marker.rotation.x = Math.PI / 2;
            marker.receiveShadow = true;
            scene.add(marker);
            
            // Hacer que el marcador parpadee
            animateMarker(marker, i * 100);
        }
        
        // Flecha indicadora (solo en puntos clave)
        if (i < path.length - 1 && (i % 5 === 0 || i === path.length - 2)) {
            const nextCell = path[i + 1];
            const arrow = new THREE.Mesh(arrowGeo, arrowMat);
            arrow.position.set(cx, 15, cz);
            
            // Calcular dirección hacia la siguiente celda
            const dx = (nextCell.c - cell.c) * cellSize;
            const dz = (nextCell.r - cell.r) * cellSize;
            const angle = Math.atan2(dx, dz);
            arrow.rotation.x = Math.PI / 2;
            arrow.rotation.z = -angle;
            
            scene.add(arrow);
            
            // Animación de flotación
            animateArrow(arrow, i * 200);
        }
    }

}

/** ========= ANIMAR MARCADORES ========= */
function animateMarker(marker, delay) {
    const originalY = marker.position.y;
    let time = delay;
    
    function animate() {
        time += 0.05;
        marker.position.y = originalY + Math.sin(time) * 2;
        marker.material.opacity = 0.6 + Math.sin(time * 2) * 0.2;
        
        // Continuar animación
        if (marker.parent) {
            requestAnimationFrame(animate);
        }
    }
    
    setTimeout(() => animate(), delay % 1000);
}

/** ========= ANIMAR FLECHAS ========= */
function animateArrow(arrow, delay) {
    const originalY = arrow.position.y;
    let time = delay;
    
    function animate() {
        time += 0.03;
        arrow.position.y = originalY + Math.sin(time) * 3;
        arrow.rotation.y += 0.01;
        
        // Continuar animación
        if (arrow.parent) {
            requestAnimationFrame(animate);
        }
    }
    
    setTimeout(() => animate(), delay % 1000);
}

// -------------------------------------------------------------------
// ---------- CREACIÓN DE ENEMIGOS ----------
// -------------------------------------------------------------------
function spawnEnemiesInMaze(count) {
    const maze = scene.userData.maze;
    if (!maze) {
        console.error("No hay laberinto generado");
        return;
    }
    
    const { startX, startZ, rows, cols, cellSize } = maze;
    
    const enemyGeo = new THREE.BoxGeometry(15, 15, 15);
    const enemyMat = new THREE.MeshStandardMaterial({ 
        color: 0xdd4444, 
        roughness: 0.8,
        emissive: 0x220000,
        emissiveIntensity: 0.1
    });
    
    let placed = 0;
    const maxAttempts = count * 10;
    let attempts = 0;
    
    while (placed < count && attempts < maxAttempts) {
        attempts++;
        
        const r = 1 + Math.floor(Math.random() * (rows - 2));
        const c = 1 + Math.floor(Math.random() * (cols - 2));
        
        const x = startX + c * cellSize + cellSize / 2;
        const z = startZ + r * cellSize + cellSize / 2;
        
        const startCellX = startX + cellSize / 2;
        const startCellZ = startZ + cellSize / 2;
        const distanceToStart = Math.hypot(x - startCellX, z - startCellZ);
        
        if (distanceToStart < cellSize * 2) continue;
        
        let tooClose = false;
        for (const enemy of enemies) {
            if (enemy.position.distanceTo(new THREE.Vector3(x, 7.5, z)) < cellSize) {
                tooClose = true;
                break;
            }
        }
        
        if (tooClose) continue;
        
        const enemy = new THREE.Mesh(enemyGeo, enemyMat);
        enemy.position.set(x, 7.5, z);
        enemy.castShadow = true;
        enemy.receiveShadow = true;
        
        enemy.userData = { 
            health: CONFIG.ENEMY_HEALTH, 
            alive: true, 
            speed: CONFIG.ENEMY_SPEED_MIN + Math.random() * (CONFIG.ENEMY_SPEED_MAX - CONFIG.ENEMY_SPEED_MIN),
            lastAttack: 0
        };
        
        scene.add(enemy);
        
        enemy.updateMatrixWorld();
        const enemyBox = new THREE.Box3().setFromObject(enemy);
        
        enemies.push(enemy);
        physicsObjects.push({ 
            mesh: enemy, 
            boundingBox: enemyBox, 
            mass: 50 
        });
        
        placed++;
    }
    
    console.log(`${placed} enemigos colocados en el laberinto`);
}

// -------------------------------------------------------------------
// ---------- CREACIÓN DEL PORTAL ----------
// -------------------------------------------------------------------
function createGoalAtEnd() {
    const maze = scene.userData.maze;
    if (!maze) return;
    
    const { startX, startZ, rows, cols, cellSize } = maze;
    
    const goalX = startX + (cols - 1) * cellSize + cellSize / 2;
    const goalZ = startZ + (rows - 1) * cellSize + cellSize / 2;
    
    const portalGeo = new THREE.TorusGeometry(30, 6, 16, 100);
    const portalMat = new THREE.MeshStandardMaterial({ 
        color: 0x22ff88, 
        emissive: 0x22ff88, 
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.9
    });
    
    const portal = new THREE.Mesh(portalGeo, portalMat);
    portal.rotation.x = Math.PI / 2;
    portal.position.set(goalX, 45, goalZ);
    portal.castShadow = true;
    scene.add(portal);
    
    createPortalParticles(goalX, goalZ);
    
    scene.userData.goal = { 
        mesh: portal, 
        position: new THREE.Vector3(goalX, 0, goalZ),
        radius: 30
    };
    
    console.log(`Portal creado en posición: (${goalX.toFixed(1)}, ${goalZ.toFixed(1)})`);
}

// -------------------------------------------------------------------
// ---------- PARTÍCULAS DEL PORTAL ----------
// -------------------------------------------------------------------
function createPortalParticles(x, z) {
    const particleCount = 50; // Reducido para mejor rendimiento
    const particleGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    
    for (let i = 0; i < particleCount; i++) {
        const radius = 25 + Math.random() * 10;
        const angle = Math.random() * Math.PI * 2;
        const height = 20 + Math.random() * 50;
        
        positions[i * 3] = x + Math.cos(angle) * radius;
        positions[i * 3 + 1] = height;
        positions[i * 3 + 2] = z + Math.sin(angle) * radius;
        
        colors[i * 3] = 0.2 + Math.random() * 0.3;
        colors[i * 3 + 1] = 0.8 + Math.random() * 0.2;
        colors[i * 3 + 2] = 0.3 + Math.random() * 0.2;
    }
    
    particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particleGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const particleMat = new THREE.PointsMaterial({
        size: 2,
        vertexColors: true,
        transparent: true,
        opacity: 0.7
    });
    
    const particles = new THREE.Points(particleGeo, particleMat);
    scene.add(particles);
    
    scene.userData.portalParticles = {
        mesh: particles,
        time: 0,
        positions: positions
    };
}

// -------------------------------------------------------------------
// ---------- CREACIÓN DEL PISO ----------
// -------------------------------------------------------------------
/** ========= CREACIÓN DEL PISO (con textura) ========= */
function createFloor() {
    const maze = scene.userData.maze;
    if (!maze) return;
    
    const { rows, cols, cellSize } = maze;
    
    const floorWidth = cols * cellSize + cellSize * 2;
    const floorHeight = rows * cellSize + cellSize * 2;
    
    // Cargar textura del piso
    const textureLoader = new THREE.TextureLoader();
    const floorTexture = textureLoader.load(CONFIG.FLOOR_TEX, (tex) => {
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        // Ajustar el repeat según el tamaño del laberinto
        tex.repeat.set(rows / 2, cols / 2);
    });
    
    const floorMat = new THREE.MeshStandardMaterial({ 
        map: floorTexture,
        roughness: 0.9,
        metalness: 0.05
    });
    
    const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(floorWidth, floorHeight),
        floorMat
    );
    
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.1;
    floor.receiveShadow = true;
    scene.add(floor);
    
    console.log(`Piso texturizado creado: ${floorWidth}x${floorHeight}`);
}

// -------------------------------------------------------------------
// ---------- INICIALIZACIÓN DEL ESCENARIO ----------
// -------------------------------------------------------------------
function createGameScene() {
    console.log("Creando escenario del juego...");
    
    // Limpiar escena si ya existe
    physicsObjects = [];
    enemies = [];
    
    // Generar laberinto
    generateMaze(CONFIG.MAZE_ROWS, CONFIG.MAZE_COLS, CONFIG.CELL_SIZE);
    
    // Crear piso
    createFloor();
    
    // Colocar enemigos
    spawnEnemiesInMaze(CONFIG.ENEMY_COUNT);
    
    // Crear portal objetivo
    createGoalAtEnd();
    
    // Posicionar al jugador
    const maze = scene.userData.maze;
    if (maze) {
        const startPos = new THREE.Vector3(
            maze.startX + CONFIG.CELL_SIZE / 2,
            10,
            maze.startZ + CONFIG.CELL_SIZE / 2
        );
        player.position.copy(startPos);
        return startPos;
    }
    
    const defaultStart = new THREE.Vector3(0, 10, 0);
    player.position.copy(defaultStart);
    return defaultStart;
}

/** ========= ANIMACIÓN DEL PORTAL ========= */
function animatePortalParticles(deltaTime) {
    const portalParticles = scene.userData.portalParticles;
    if (!portalParticles) return;
    
    portalParticles.time += deltaTime;
    const positions = portalParticles.positions;
    const portalPos = scene.userData.goal.position;
    
    for (let i = 0; i < positions.length / 3; i++) {
        const idx = i * 3;
        const radius = 25 + Math.random() * 10;
        const angle = (portalParticles.time * 0.5 + i * 0.1) % (Math.PI * 2);
        const height = 20 + Math.sin(portalParticles.time + i) * 10;
        
        positions[idx] = portalPos.x + Math.cos(angle) * radius;
        positions[idx + 1] = height;
        positions[idx + 2] = portalPos.z + Math.sin(angle) * radius;
    }
    
    portalParticles.mesh.geometry.attributes.position.needsUpdate = true;
    portalParticles.mesh.rotation.y += deltaTime * 0.2;
    
    if (scene.userData.goal) {
        scene.userData.goal.mesh.rotation.y += deltaTime * 0.5;
    }
}

/** ========= LOCOMOCIÓN VR ========= */
function vrGamepadMove(dt) {
    if (!renderer.xr.isPresenting) return;
    
    const session = renderer.xr.getSession();
    if (!session) return;
    
    for (const src of session.inputSources) {
        if (!src.gamepad) continue;
        
        let [x, y] = [src.gamepad.axes[2], src.gamepad.axes[3]];
        if (x === undefined || y === undefined) {
            x = src.gamepad.axes[0] ?? 0;
            y = src.gamepad.axes[1] ?? 0;
        }
        
        const dead = 0.12;
        if (Math.abs(x) < dead) x = 0;
        if (Math.abs(y) < dead) y = 0;
        if (x === 0 && y === 0) continue;

        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();
        
        const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize();

        let next = player.position.clone();
        next.addScaledVector(forward, -y * CONFIG.VR_WALK_SPEED * dt);
        next.addScaledVector(right, x * CONFIG.VR_STRAFE_SPEED * dt);

        const maze = scene.userData.maze;
        if (maze) {
            const halfWidth = (maze.cols * CONFIG.CELL_SIZE) / 2 - 5;
            const halfHeight = (maze.rows * CONFIG.CELL_SIZE) / 2 - 5;
            next.x = Math.max(-halfWidth, Math.min(halfWidth, next.x));
            next.z = Math.max(-halfHeight, Math.min(halfHeight, next.z));
        }

        next.y = -0.1 + 1.6;
        next = resolveCollisions(player.position, next);
        player.position.copy(next);
    }
}

/** ========= TELEPORT ========= */
function updateTeleportArc() {
    if (!arcLine || !arcLine.visible) return;
    if (!controllerRight) return;
    
    teleportValid = false;

    const origin = new THREE.Vector3().setFromMatrixPosition(controllerRight.matrixWorld);
    const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(controllerRight.quaternion).normalize();

    const pts = [];
    let hit = null;
    const v0 = dir.clone().multiplyScalar(CONFIG.ARC_SPEED);
    const g = new THREE.Vector3(0, -CONFIG.ARC_GRAVITY, 0);
    let p = origin.clone(), v = v0.clone();

    for (let i = 0; i < CONFIG.ARC_STEPS; i++) {
        pts.push(p.clone());
        v.addScaledVector(g, 1 / 60);
        const np = p.clone().addScaledVector(v, 1 / 60);
        
        if (np.y <= -0.1) {
            hit = { point: new THREE.Vector3(np.x, -0.1, np.z), faceNormal: new THREE.Vector3(0, 1, 0) };
            break;
        }
        p.copy(np);
    }

    for (let i = 0; i < CONFIG.ARC_STEPS; i++) {
        const P = pts[Math.min(i, pts.length - 1)];
        arcPointsBuf[i * 3] = P.x;
        arcPointsBuf[i * 3 + 1] = P.y;
        arcPointsBuf[i * 3 + 2] = P.z;
    }
    
    arcGeo.setAttribute('position', new THREE.BufferAttribute(arcPointsBuf, 3));
    arcGeo.attributes.position.needsUpdate = true;

    if (hit) {
        const maze = scene.userData.maze;
        let inside = true;
        if (maze) {
            const halfWidth = (maze.cols * CONFIG.CELL_SIZE) / 2 - 2;
            const halfHeight = (maze.rows * CONFIG.CELL_SIZE) / 2 - 2;
            inside = Math.abs(hit.point.x) <= halfWidth && Math.abs(hit.point.z) <= halfHeight;
        }
        
        teleportValid = inside;
        arcLine.material = teleportValid ? arcMatOK : arcMatBAD;
        marker.material.color.set(teleportValid ? 0x7ad1ff : 0xff5a5a);
        marker.position.set(hit.point.x, -0.1 + 0.02, hit.point.z);
        teleportPoint.copy(hit.point);
    }
}

/** ========= COLISIONES ========= */
function resolveCollisions(curr, next) {
    // Paredes del laberinto
    for (const obj of physicsObjects) {
        if (!obj.static) continue;
        
        const box = obj.boundingBox.clone();
        const playerBox = new THREE.Box3(
            new THREE.Vector3(next.x - CONFIG.PLAYER_RADIUS, next.y - 1.6, next.z - CONFIG.PLAYER_RADIUS),
            new THREE.Vector3(next.x + CONFIG.PLAYER_RADIUS, next.y, next.z + CONFIG.PLAYER_RADIUS)
        );
        
        if (box.intersectsBox(playerBox)) {
            const dx = next.x - obj.mesh.position.x;
            const dz = next.z - obj.mesh.position.z;
            const dist = Math.hypot(dx, dz);
            const minDist = CONFIG.PLAYER_RADIUS + CONFIG.WALL_THICKNESS / 2;
            
            if (dist < minDist && dist > 0) {
                const push = (minDist - dist) + 0.1;
                const nx = dx / dist;
                const nz = dz / dist;
                next.x += nx * push;
                next.z += nz * push;
            }
        }
    }
    
    // Enemigos
    for (const enemy of enemies) {
        if (!enemy.userData.alive) continue;
        
        const dx = next.x - enemy.position.x;
        const dz = next.z - enemy.position.z;
        const dist = Math.hypot(dx, dz);
        const minDist = CONFIG.PLAYER_RADIUS + 7.5;
        
        if (dist < minDist) {
            const push = (minDist - dist) + 0.1;
            const nx = dx / (dist || 1);
            const nz = dz / (dist || 1);
            next.x += nx * push;
            next.z += nz * push;
            
            // Daño al jugador
            takeDamage(CONFIG.ENEMY_ATTACK_DAMAGE);
        }
    }
    
    return next;
}

/** ========= DAÑO AL JUGADOR ========= */
function takeDamage(amount) {
    const lifeElement = document.getElementById('life');
    if (!lifeElement) return;
    
    let currentLife = parseInt(lifeElement.textContent);
    currentLife = Math.max(0, currentLife - amount);
    lifeElement.textContent = currentLife;
    
    // Actualizar letrero VR si está visible
    const vrLife = document.getElementById('vr-life');
    if (vrLife) {
        vrLife.textContent = currentLife;
    }
    
    if (currentLife <= 0) {
        gameOver();
    }
}

/** ========= GAME OVER ========= */
function gameOver() {
    showMessage("GAME OVER\nLos aliens te atraparon", false);
    
    // Detener el juego
    renderer.setAnimationLoop(null);
    
    // Mostrar botón de reinicio
    const restartBtn = document.getElementById('restartBtn');
    if (restartBtn) {
        restartBtn.style.display = 'block';
        restartBtn.onclick = restartGame;
    }
}

/** ========= REINICIAR JUEGO ========= */
function restartGame() {
    // Ocultar mensaje y botón
    const messageEl = document.getElementById('message');
    const restartBtn = document.getElementById('restartBtn');
    if (messageEl) messageEl.style.display = 'none';
    if (restartBtn) restartBtn.style.display = 'none';
    
    // Restaurar vida
    const lifeElement = document.getElementById('life');
    if (lifeElement) lifeElement.textContent = '100';
    
    // Actualizar letrero VR si está visible
    const vrLife = document.getElementById('vr-life');
    if (vrLife) {
        vrLife.textContent = '100';
    }
    
    // Limpiar escena
    while (scene.children.length > 0) {
        const child = scene.children[0];
        if (child !== player && child !== controllerLeft && child !== controllerRight && 
            child !== grip0 && child !== grip1 && child !== arcLine && child !== marker) {
            scene.remove(child);
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(m => m.dispose());
                } else {
                    child.material.dispose();
                }
            }
        }
    }
    
    // Reinicializar variables
    physicsObjects = [];
    enemies = [];
    
    // Crear nuevo escenario
    createGameScene();
    
    // Reiniciar loop
    renderer.setAnimationLoop(gameLoop);
}

/** ========= VICTORIA ========= */
function checkVictory() {
    if (!scene.userData.goal) return;
    
    const distanceToGoal = player.position.distanceTo(scene.userData.goal.position);
    if (distanceToGoal < scene.userData.goal.radius) {
        showMessage("¡VICTORIA!\nPortal alcanzado", true);
        
        // Detener el juego
        renderer.setAnimationLoop(null);
        
        // Mostrar botón de reinicio
        const restartBtn = document.getElementById('restartBtn');
        if (restartBtn) {
            restartBtn.style.display = 'block';
            restartBtn.onclick = restartGame;
        }
        
        // Efectos de victoria
        createVictoryEffects();
    }
}

/** ========= EFECTOS DE VICTORIA ========= */
function createVictoryEffects() {
    // Crear confeti
    const confettiCount = 100; // Reducido para mejor rendimiento
    const confettiGeo = new THREE.BufferGeometry();
    const positions = new Float32Array(confettiCount * 3);
    const colors = new Float32Array(confettiCount * 3);
    
    for (let i = 0; i < confettiCount; i++) {
        const i3 = i * 3;
        positions[i3] = player.position.x + (Math.random() - 0.5) * 50;
        positions[i3 + 1] = player.position.y + Math.random() * 100;
        positions[i3 + 2] = player.position.z + (Math.random() - 0.5) * 50;
        
        colors[i3] = Math.random();
        colors[i3 + 1] = Math.random();
        colors[i3 + 2] = Math.random();
    }
    
    confettiGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    confettiGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const confettiMat = new THREE.PointsMaterial({
        size: 3,
        vertexColors: true,
        transparent: true,
        opacity: 0.8
    });
    
    const confetti = new THREE.Points(confettiGeo, confettiMat);
    scene.add(confetti);
    
    // Animar confeti
    function animateConfetti() {
        const positions = confettiGeo.attributes.position.array;
        for (let i = 0; i < confettiCount; i++) {
            const i3 = i * 3;
            positions[i3 + 1] -= 1;
            if (positions[i3 + 1] < player.position.y - 20) {
                positions[i3 + 1] = player.position.y + Math.random() * 100;
            }
        }
        confettiGeo.attributes.position.needsUpdate = true;
        requestAnimationFrame(animateConfetti);
    }
    animateConfetti();
}

/** ========= ACTUALIZAR HUD Y LETRERO VR ========= */
function updateHUD() {
    const enemiesCount = document.getElementById('enemiesCount');
    if (enemiesCount) {
        enemiesCount.textContent = enemies.filter(e => e.userData.alive).length;
    }
    
    // También actualizar el letrero VR si está visible
    const vrSign = document.getElementById('vr-enter-sign');
    if (vrSign && vrSign.style.display === 'block') {
        const vrLife = document.getElementById('vr-life');
        const vrEnemies = document.getElementById('vr-enemies');
        const lifeElement = document.getElementById('life');
        
        if (vrLife && vrEnemies && lifeElement) {
            vrLife.textContent = lifeElement.textContent;
            vrEnemies.textContent = enemies.filter(e => e.userData.alive).length;
        }
    }
}

/** ========= MOSTRAR MENSAJES ========= */
function showMessage(text, isVictory = false) {
    const messageEl = document.getElementById('message');
    if (messageEl) {
        messageEl.textContent = text;
        messageEl.style.display = 'block';
        messageEl.style.color = isVictory ? '#22ff88' : '#ff4444';
        messageEl.style.borderColor = isVictory ? '#22ff88' : '#ff4444';
        
        if (isVictory) {
            setTimeout(() => {
                messageEl.style.display = 'none';
            }, 5000);
        }
    }
}

/** ========= LOOP DEL JUEGO ========= */
function gameLoop() {
    try {
        const dt = Math.min(clock.getDelta(), 0.05);

        if (renderer.xr.isPresenting) {
            vrGamepadMove(dt);
            updateTeleportArc();
        }

        // Mantener fondo centrado
        const p = player.position;
        if (skyMesh) skyMesh.position.copy(p);
        if (starField) starField.position.copy(p);

        // Animar partículas del portal
        animatePortalParticles(dt);

        // Actualizar UI
        updateHUD();

        // Verificar victoria
        checkVictory();

        // Renderizar
        renderer.clear();
        if (bgCam && camera) {
            bgCam.projectionMatrix.copy(camera.projectionMatrix);
            bgCam.matrixWorld.copy(camera.matrixWorld);
            bgCam.matrixWorldInverse.copy(camera.matrixWorldInverse);
            renderer.render(bgScene, bgCam);
        }
        renderer.render(scene, camera);
    } catch (error) {
        console.error("Error en gameLoop:", error);
    }
}

/** ========= INICIALIZAR JUEGO ========= */
function initGame() {
    if (gameInitialized) {
        console.log("Juego ya inicializado");
        return;
    }
    
    console.log("Iniciando juego...");
    
    try {
        // Ocultar portada
        const portada = document.getElementById('portada');
        portada.style.display = 'none';
        
        // Mostrar elementos del juego
        const canvas = document.getElementById('scene');
        canvas.style.display = 'block';
        
        const hud = document.getElementById('hud');
        if (hud) hud.style.display = 'block';
        
        const crosshair = document.querySelector('.crosshair');
        if (crosshair) crosshair.style.display = 'block';
        
        const footer = document.querySelector('footer');
        if (footer) footer.style.display = 'flex';
        
        const vrInfo = document.getElementById('vr-info');
        if (vrInfo) vrInfo.style.display = 'block';
        
        // Inicializar Three.js
        initRenderer();
        initScenes();
        initLights();
        initSky();
        initAudio();
        initVR();
        
        // Crear escenario del juego
        createGameScene();
        
        // Iniciar loop del juego
        renderer.setAnimationLoop(gameLoop);
        
        gameInitialized = true;
        
        // Actualizar HUD inicial
        updateHUD();
        
        console.log("Juego inicializado correctamente");
        
        // Activar audio después de interacción del usuario
        document.addEventListener('click', function activateAudio() {
            const backgroundMusic = document.getElementById('backgroundMusic');
            if (backgroundMusic) {
                backgroundMusic.play().catch(e => console.log('Audio activado'));
            }
            document.removeEventListener('click', activateAudio);
        });
        
    } catch (error) {
        console.error("Error al inicializar el juego:", error);
        alert("Error al iniciar el juego: " + error.message);
    }
}

/** ========= RESIZE ========= */
window.addEventListener('resize', () => {
    if (!gameInitialized) return;
    
    if (camera) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    }
    
    if (bgCam) {
        bgCam.aspect = window.innerWidth / window.innerHeight;
        bgCam.updateProjectionMatrix();
    }
    
    if (renderer) {
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
});

/** ========= EVENTOS ========= */
document.addEventListener('DOMContentLoaded', () => {
    console.log("Documento cargado");
    
    // Botón de inicio
    const startBtn = document.getElementById('startBtn');
    if (startBtn) {
        startBtn.addEventListener('click', initGame);
    }
    
    // También permitir iniciar con Enter
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !gameInitialized) {
            initGame();
        }
    });
    
    // Botón de reinicio (oculto inicialmente)
    const restartBtn = document.getElementById('restartBtn');
    if (restartBtn) {
        restartBtn.onclick = restartGame;
    }
    
    console.log("Listo para iniciar... Presiona el botón 'Iniciar Experiencia VR'");
});
    </script>
</body>
</html>